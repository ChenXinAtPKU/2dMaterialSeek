import re
import sympy
import math
#尚存疑问：1，切割起始位置是否会造成所获得2D切片只含有一个原子的状况


#读取文件
txt = open('POSCAR', 'r')
content = txt.read()

# 读取晶格常数
matchp = re.match(r'(.*)\n(.*)\n(.*)\n(.*)\n(.*)', content)
print(matchp.group())
xLat = matchp.group(3)
x = re.split(' ', xLat)[0]
yLat = matchp.group(4)
y = re.split(' ', yLat)[1]
zLat = matchp.group(5)
z = re.split(' ', zLat)[2]

txt.close()
txt = open('POSCAR', 'r')

# 读取原子位置
line = []
for i in range(8):
    txt.readline()
while 1:
    posLine = txt.readline()
    if not posLine:
        break
    line.append(re.split(' ', posLine))
txt.close()

# 输出位置信息
pos = []
for i in range(len(line)*27):
    pos.append([])

#duplicate position sites
    for j in range(3):
        i1=i
        if i>=len(line):
            i1=i%len(line)
        pos[i].append(float(line[i1][j]))
#向三个方向扩展
iii=0
for i in [0,1,-1]:
    for o in [0,1,-1]:
        for p in [0,1,-1]:
            for oo in range(len(line)):
                pos[len(line)*iii + oo][0] = pos[len(line)*iii +oo][0]+i
                pos[len(line) * iii + oo][1] = pos[len(line) * iii + oo][1] + o
                pos[len(line) * iii + oo][2] = pos[len(line) * iii + oo][2] + p
            iii=1+iii


position = pos

#点投影到直线上
def reflect(h,k,l,position):
    linePosition=[]
    a = sympy.Symbol('a')
    b = sympy.Symbol('b')
    c = sympy.Symbol('c')
    for i in range(len(position)):
        x = position[i][0]
        y = position[i][1]
        z = position[i][2]
        linePos = sympy.solve([h*b-a*k, k*c-b*l, h*c-l*a, (x - a) * h + (y - b) * k + (z - c) * l],[a, b, c])
        if linePos[a]<0 or linePos[b]<0 or linePos[c]<0:
            siteAtLine = -(linePos[a] ** 2 + linePos[b] ** 2 + linePos[c] ** 2) ** 0.5
        else:
            siteAtLine=(linePos[a]**2+linePos[b]**2+linePos[c]**2)**0.5
        linePosition.append(siteAtLine)
    linePosition.sort()
#线上点与点的距离计算
    distance=[]
    for i in range(len(linePosition)-1):
        Dis=linePosition[i+1]-linePosition[i]
        distance.append(Dis)
    MaxDistance=max(distance)
    return MaxDistance;
list1=[]
hklMaxDistance=[]

#寻找最大层间距
for h in range(2):
    h=1-h
    for k in range(2):
        k=1-k
        for l in range(2):
            l=1-l
            if h==k==l and h!=1:
                continue
            chuanzhi=reflect(h,k,l,position)
            hklMaxDistance.append(chuanzhi)
            list1.append((str(chuanzhi),str(h)+str(k)+str(l)))
listDict=dict(list1)
new=open('newtxt.txt','w')
new.write(str(listDict))
#找到其晶面指数
print(listDict.get(max(listDict)))


#求最大层间距，单位为A
p=sympy.Symbol('p')
p=abs(float(sympy.solve([(p*int(listDict.get(max(listDict))[0]))**2+(p*int(listDict.get(max(listDict))[1]))**2+(p*int(listDict.get(max(listDict))[2]))**2-float(max(listDict))**2],[p])[0][0]))
distanceA=((p*int(listDict.get(max(listDict))[0])*float(x))**2.0+(p*int(listDict.get(max(listDict))[1])*float(y))**2.0+(p*int(listDict.get(max(listDict))[2])*float(z))**2.0)**0.5

#cut
MaxHkl=list(listDict.get(max(listDict)))
MaxHkl[0]=int(MaxHkl[0]);MaxHkl[1]=int(MaxHkl[1]);MaxHkl[2]=int(MaxHkl[2])

a = sympy.Symbol('a')
b = sympy.Symbol('b')
c = sympy.Symbol('c')
linePosition=[]
pointData=[]
for i in range(len(position)):
    pointData.append([])
    x = position[i][0]
    y = position[i][1]
    z = position[i][2]
    linePos = sympy.solve([MaxHkl[0] * b - a * MaxHkl[1], MaxHkl[1] * c - b * MaxHkl[2], MaxHkl[0] * c - MaxHkl[2] * a, (x - a) * MaxHkl[0] + (y - b) * MaxHkl[1] + (z - c) * MaxHkl[2]], [a, b, c])
    if linePos[a] < 0 or linePos[b] < 0 or linePos[c] < 0:
        siteAtLine = -(linePos[a] ** 2 + linePos[b] ** 2 + linePos[c] ** 2) ** 0.5
    else:
        siteAtLine = (linePos[a] ** 2 + linePos[b] ** 2 + linePos[c] ** 2) ** 0.5
    linePosition.append(siteAtLine)
    pointData[i].append(siteAtLine)
    pointData[i].append(linePos)
    pointData[i].append([x,y,z])
    #pointData[I][0]是线上位置至原点距离，pointData[I][1]是线上位置信息，pointData[I][2]是原始位置信息
    #from small to big
distance=[]
#寻找切割起始位置
pointData.sort()
point0 = 0
for i in range(len(pointData)-1):
    Dis=pointData[i+1][0]-pointData[i][0]
    if Dis-float(max(listDict))<0.0001:
        point0=i+1
        break

#从起始位置切割并建立新的poscar
modifiedPointData=[]
iftrue=1
for i in range(len(pointData)-1):
    if i>=point0 and iftrue==1:
        if abs(pointData[i+1][0]-pointData[i][0]-float(max(listDict)))<0.0001:
            iftrue=0
        modifiedPointData.append(pointData[i])
for i in range(len(modifiedPointData)):
    del modifiedPointData[i][1]
    del modifiedPointData[i][0]




